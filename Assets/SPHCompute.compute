// SPHCompute.compute

// Each #pragma kernel line tells Unity about a kernel entry point.
#pragma kernel CS_Clear
#pragma kernel CS_ClearGrid
#pragma kernel CS_BuildGrid
#pragma kernel CS_DensityPressure
#pragma kernel CS_ComputeForces
#pragma kernel CS_XSPH
#pragma kernel CS_VV_HalfStep
#pragma kernel CS_VV_FullStep
#pragma kernel CS_Boundaries
#pragma kernel CS_ObstacleCollision
#pragma kernel CS_VelocityDamping

static const float PI = 3.14159265359;

// --------------------------------------------------------------------
// Utility: Pseudo-Random Generator
// A simple hash-based function to break symmetry at boundaries.
// --------------------------------------------------------------------
float rand(float2 co)
{
    return frac(sin(dot(co, float2(12.9898, 78.233))) * 43758.5453);
}

// --------------------------------------------------------------------
// Data Structures
// --------------------------------------------------------------------
struct Particle
{
    float3 position;
    float3 velocity;
    float3 acceleration;
    float  density;
    float  pressure;
};

// Buffer containing all particles
RWStructuredBuffer<Particle> Particles;

// Grid buffers for spatial hashing:
RWStructuredBuffer<int> GridCounts;   // Array of length (gridResolutionX * gridResolutionY * gridResolutionZ)
RWStructuredBuffer<int> GridIndices;    // Array of length (totalCells * _MaxParticlesPerCell)

// --------------------------------------------------------------------
// Simulation Parameters
// --------------------------------------------------------------------
cbuffer SimulationParams
{
    int   _ParticleCount;
    float _DeltaTime;
    float _ParticleMass;
    float _RestDensity;
    float _Stiffness;
    float _Viscosity;
    float _SmoothingRadius;
    float _Gravity;
    float _SurfaceTensionCoefficient;
    float _XSPHEpsilon;
    float _ParticleCollisionDamping;
    float _ObstacleRepulsionStiffness;
    float _ObstacleRadius;
    float3 _BoundsCenter;
    float3 _BoundsSize;
    float3 _SpawnCenter;
    float3 _SpawnSize;
    float3 _ObstaclePos;

    // New grid parameters:
    int _GridResolutionX;
    int _GridResolutionY;
    int _GridResolutionZ;
    int _MaxParticlesPerCell;
    float _CellSize;
    float3 _MinBound;

    // Oriented boundary parameters (sent from C# when a boundary cube is assigned)
    float4x4 _BoundaryMatrix;
    float4x4 _BoundaryInvMatrix;  // Precomputed inverse (world-to-local)
    float3 _BoundaryHalfExtents;
}

// --------------------------------------------------------------------
// KERNEL: CS_Clear
// Reset per-particle accumulators (acceleration, density, pressure).
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_Clear(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];
    p.acceleration = 0.0;
    p.density = _RestDensity;
    p.pressure = 0.0;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_ClearGrid
// Reset the grid cell particle counts.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ClearGrid(uint3 id : SV_DispatchThreadID)
{
    uint cellIndex = id.x;
    int totalCells = _GridResolutionX * _GridResolutionY * _GridResolutionZ;
    if (cellIndex >= (uint)totalCells) return;
    GridCounts[cellIndex] = 0;
}

// --------------------------------------------------------------------
// KERNEL: CS_BuildGrid
// For each particle, compute its grid cell and store its index.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_BuildGrid(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];
    float3 pos = p.position;
    int3 cellCoord = int3(floor((pos - _MinBound) / _CellSize));
    // Clamp to valid grid coordinates.
    cellCoord = clamp(cellCoord, int3(0, 0, 0), int3(_GridResolutionX - 1, _GridResolutionY - 1, _GridResolutionZ - 1));
    int cellIndex = cellCoord.x + cellCoord.y * _GridResolutionX + cellCoord.z * _GridResolutionX * _GridResolutionY;

    uint count;
    InterlockedAdd(GridCounts[cellIndex], 1, count);
    if (count < _MaxParticlesPerCell)
    {
        int offset = cellIndex * _MaxParticlesPerCell + count;
        GridIndices[offset] = idx;
    }
}

// --------------------------------------------------------------------
// KERNEL: CS_DensityPressure
// Compute density and pressure using neighbor particles from nearby grid cells.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_DensityPressure(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle self = Particles[idx];
    float h = _SmoothingRadius;
    float h2 = h * h;
    float poly6 = 315.0 / (64.0 * PI * pow(h, 9.0));
    float density = 0.0;

    float3 pos = self.position;
    float3 minBound = _MinBound;
    int3 cell = int3(floor((pos - minBound) / _CellSize));

    // Loop over neighboring cells (3x3x3)
    for (int z = cell.z - 1; z <= cell.z + 1; z++)
    {
        for (int y = cell.y - 1; y <= cell.y + 1; y++)
        {
            for (int x = cell.x - 1; x <= cell.x + 1; x++)
            {
                if (x < 0 || x >= _GridResolutionX || y < 0 || y >= _GridResolutionY || z < 0 || z >= _GridResolutionZ)
                    continue;
                int neighborCellIndex = x + y * _GridResolutionX + z * _GridResolutionX * _GridResolutionY;
                int neighborCount = GridCounts[neighborCellIndex];
                for (int k = 0; k < neighborCount; k++)
                {
                    int j = GridIndices[neighborCellIndex * _MaxParticlesPerCell + k];
                    if (j == idx) continue;
                    Particle other = Particles[j];
                    float3 r = self.position - other.position;
                    float rSq = dot(r, r);
                    if (rSq < h2)
                    {
                        float diff = (h2 - rSq);
                        density += _ParticleMass * poly6 * pow(diff, 3.0);
                    }
                }
            }
        }
    }
    density = max(density, _RestDensity);
    self.density = density;
    self.pressure = _Stiffness * (density - _RestDensity);
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_ComputeForces
// Compute forces (pressure, viscosity, surface tension) using grid-based neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ComputeForces(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle self = Particles[idx];
    float densitySelf = self.density;
    if (densitySelf < 1e-6) return;

    float h = _SmoothingRadius;
    float h2 = h * h;
    float h6 = pow(h, 6.0);

    float spikyGrad = -45.0 / (PI * h6);
    float viscLap = 45.0 / (PI * h6);

    float3 force = float3(0.0, _Gravity * densitySelf, 0.0);
    float3 colorGradient = float3(0.0, 0.0, 0.0);

    float3 pos = self.position;
    float3 minBound = _MinBound;
    int3 cell = int3(floor((pos - minBound) / _CellSize));

    for (int z = cell.z - 1; z <= cell.z + 1; z++)
    {
        for (int y = cell.y - 1; y <= cell.y + 1; y++)
        {
            for (int x = cell.x - 1; x <= cell.x + 1; x++)
            {
                if (x < 0 || x >= _GridResolutionX || y < 0 || y >= _GridResolutionY || z < 0 || z >= _GridResolutionZ)
                    continue;
                int neighborCellIndex = x + y * _GridResolutionX + z * _GridResolutionX * _GridResolutionY;
                int neighborCount = GridCounts[neighborCellIndex];
                for (int k = 0; k < neighborCount; k++)
                {
                    int j = GridIndices[neighborCellIndex * _MaxParticlesPerCell + k];
                    if (j == idx) continue;
                    Particle other = Particles[j];
                    float3 r = self.position - other.position;
                    float rSq = dot(r, r);
                    if (rSq > h2) continue;
                    float dist = sqrt(rSq) + 1e-6;
                    float3 dir = r / dist;

                    float pressTerm = (self.pressure + other.pressure) / (2.0 * other.density);
                    float3 gradW = spikyGrad * pow(h - dist, 2.0) * dir;
                    force += -_ParticleMass * pressTerm * gradW;

                    float3 dv = (other.velocity - self.velocity);
                    float viscTerm = _Viscosity * _ParticleMass;
                    float lapW = viscLap * (h - dist);
                    force += (viscTerm * dv / other.density) * lapW;

                    colorGradient += _ParticleMass * gradW / other.density;
                }
            }
        }
    }
    float3 surfaceTension = _SurfaceTensionCoefficient * colorGradient;
    force += surfaceTension;

    self.acceleration = force / densitySelf;
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_XSPH
// Optional velocity smoothing using grid-based neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_XSPH(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle self = Particles[idx];
    float h = _SmoothingRadius;
    float h2 = h * h;
    float poly6 = 315.0 / (64.0 * PI * pow(h, 9.0));

    float3 velocityCorrection = float3(0.0, 0.0, 0.0);
    float normFactor = 0.0;

    float3 pos = self.position;
    float3 minBound = _MinBound;
    int3 cell = int3(floor((pos - minBound) / _CellSize));

    for (int z = cell.z - 1; z <= cell.z + 1; z++)
    {
        for (int y = cell.y - 1; y <= cell.y + 1; y++)
        {
            for (int x = cell.x - 1; x <= cell.x + 1; x++)
            {
                if (x < 0 || x >= _GridResolutionX || y < 0 || y >= _GridResolutionY || z < 0 || z >= _GridResolutionZ)
                    continue;
                int neighborCellIndex = x + y * _GridResolutionX + z * _GridResolutionX * _GridResolutionY;
                int neighborCount = GridCounts[neighborCellIndex];
                for (int k = 0; k < neighborCount; k++)
                {
                    int j = GridIndices[neighborCellIndex * _MaxParticlesPerCell + k];
                    if (j == idx) continue;
                    Particle other = Particles[j];
                    float3 r = self.position - other.position;
                    float rSq = dot(r, r);
                    if (rSq < h2)
                    {
                        float W = poly6 * pow(h2 - rSq, 3.0);
                        float rho_ij = 0.5 * (self.density + other.density);
                        float3 dv = (other.velocity - self.velocity);
                        velocityCorrection += dv * W * (_ParticleMass / rho_ij);
                        normFactor += W * (_ParticleMass / rho_ij);
                    }
                }
            }
        }
    }
    if (normFactor > 1e-6)
    {
        velocityCorrection *= (_XSPHEpsilon / normFactor);
        self.velocity += velocityCorrection;
    }
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_VV_HalfStep
// Velocity Verlet half-step update.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VV_HalfStep(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];
    p.velocity += 0.5 * _DeltaTime * p.acceleration;
    p.position += p.velocity * _DeltaTime;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_VV_FullStep
// Velocity Verlet full-step update.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VV_FullStep(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];
    p.velocity += 0.5 * _DeltaTime * p.acceleration;
    Particles[idx] = p;
}


// --------------------------------------------------------------------
// KERNEL: CS_Boundaries
// Bounce particles off the boundaries.
// Uses an oriented boundary if _BoundaryHalfExtents is non-zero,
// otherwise falls back to the axis–aligned boundary.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_Boundaries(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];

    // If an oriented boundary is provided (non-zero half-extents), use it.
    if (length(_BoundaryHalfExtents) > 0.001)
    {
        // Transform the particle's world position into the boundary's local space.
        float4 localPos4 = mul(_BoundaryInvMatrix, float4(p.position, 1.0));
        float3 localPos = localPos4.xyz;

        // The unit cube extends from -0.5 to +0.5 on each axis.
        float3 E = float3(0.5, 0.5, 0.5); // fixed for a unit cube collision volume
        float3 penetration = float3(0.0, 0.0, 0.0);
        bool collided = false;

        // Check each axis and compute penetration.
        if (localPos.x < -E.x)
        {
            penetration.x = -E.x - localPos.x;
            localPos.x = -E.x;
            collided = true;
        }
        else if (localPos.x > E.x)
        {
            penetration.x = localPos.x - E.x;
            localPos.x = E.x;
            collided = true;
        }
        if (localPos.y < -E.y)
        {
            penetration.y = -E.y - localPos.y;
            localPos.y = -E.y;
            collided = true;
        }
        else if (localPos.y > E.y)
        {
            penetration.y = localPos.y - E.y;
            localPos.y = E.y;
            collided = true;
        }
        if (localPos.z < -E.z)
        {
            penetration.z = -E.z - localPos.z;
            localPos.z = -E.z;
            collided = true;
        }
        else if (localPos.z > E.z)
        {
            penetration.z = localPos.z - E.z;
            localPos.z = E.z;
            collided = true;
        }

        if (collided)
        {
            // Transform corrected local position back to world space.
            float4 worldPos = mul(_BoundaryMatrix, float4(localPos, 1.0));
            p.position = worldPos.xyz;

            // Instead of completely inverting velocity,
            // blend (lerp) the velocity with its negative using a restitution factor.
            // Lower restitution makes the collision less bouncy.
            float restitutionFactor = 0.3; // adjust between 0 (no bounce) and 1 (full bounce)
            if (penetration.x > 0.0)
                p.velocity.x = lerp(p.velocity.x, -p.velocity.x, restitutionFactor);
            if (penetration.y > 0.0)
                p.velocity.y = lerp(p.velocity.y, -p.velocity.y, restitutionFactor);
            if (penetration.z > 0.0)
                p.velocity.z = lerp(p.velocity.z, -p.velocity.z, restitutionFactor);
        }
    }
    else
    {
        // Fallback: axis-aligned collision (unchanged).
        float3 halfSize = _BoundsSize * 0.5;
        float3 minBound = _BoundsCenter - halfSize;
        float3 maxBound = _BoundsCenter + halfSize;
        float velocityDamping = 0.9;
        float offset = 1e-3;

        if (p.position.x < minBound.x)
        {
            p.position.x = minBound.x;
            if (p.velocity.x < 0) p.velocity.x = -p.velocity.x * velocityDamping;
        }
        else if (p.position.x > maxBound.x)
        {
            p.position.x = maxBound.x;
            if (p.velocity.x > 0) p.velocity.x = -p.velocity.x * velocityDamping;
        }
        if (p.position.y < minBound.y)
        {
            p.position.y = minBound.y;
            if (p.velocity.y < 0) p.velocity.y = -p.velocity.y * velocityDamping;
        }
        else if (p.position.y > maxBound.y)
        {
            p.position.y = maxBound.y;
            if (p.velocity.y > 0) p.velocity.y = -p.velocity.y * velocityDamping;
        }
        if (p.position.z < minBound.z)
        {
            p.position.z = minBound.z;
            if (p.velocity.z < 0) p.velocity.z = -p.velocity.z * velocityDamping;
        }
        else if (p.position.z > maxBound.z)
        {
            p.position.z = maxBound.z;
            if (p.velocity.z > 0) p.velocity.z = -p.velocity.z * velocityDamping;
        }
    }

    Particles[idx] = p;
}



// --------------------------------------------------------------------
// KERNEL: CS_ObstacleCollision
// Handle simple sphere obstacle collisions with damping.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ObstacleCollision(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];
    float obstRadius = _ObstacleRadius;
    if (obstRadius <= 0.0) return;

    float3 toParticle = p.position - _ObstaclePos;
    float dist = length(toParticle);

    if (dist < obstRadius && dist > 1e-6)
    {
        float penetration = obstRadius - dist;
        float3 normal = toParticle / dist;
        p.position += normal * penetration;
        p.velocity = reflect(p.velocity, normal) * _ParticleCollisionDamping;
    }
    else if (dist <= 1e-6)
    {
        p.position += float3(0, obstRadius + 0.01, 0);
        p.velocity = reflect(p.velocity, float3(0, 1, 0)) * _ParticleCollisionDamping;
    }
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_VelocityDamping
// Additional velocity damping to help particles settle.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VelocityDamping(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_ParticleCount) return;

    Particle p = Particles[idx];
    float speed = length(p.velocity);
    if (speed < 0.01)
    {
        p.velocity = float3(0.0, 0.0, 0.0);
    }
    else
    {
        p.velocity *= 0.98;
    }
    Particles[idx] = p;
}
