#pragma kernel CS_Clear
#pragma kernel CS_DensityPressure
#pragma kernel CS_ComputeForces
#pragma kernel CS_XSPH
#pragma kernel CS_VV_HalfStep
#pragma kernel CS_VV_FullStep
#pragma kernel CS_Boundaries
#pragma kernel CS_ObstacleCollision
#pragma kernel CS_VelocityDamping

static const float PI = 3.14159265359;

// --------------------------------------------------------------------
// Data Structures
// --------------------------------------------------------------------
struct Particle
{
    float3 position;
    float3 velocity;
    float3 acceleration;
    float  density;
    float  pressure;
};

// Buffer containing all particles
RWStructuredBuffer<Particle> Particles;

// --------------------------------------------------------------------
// Simulation Parameters
// --------------------------------------------------------------------
cbuffer SimulationParams
{
    int   _ParticleCount;
    float _DeltaTime;
    float _ParticleMass;
    float _RestDensity;
    float _Stiffness;
    float _Viscosity;
    float _SmoothingRadius;
    float _Gravity;
    float _SurfaceTensionCoefficient;
    float _XSPHEpsilon;
    float _ParticleCollisionDamping;
    float _ObstacleRepulsionStiffness;
    float _ObstacleRadius;
    float3 _BoundsCenter;
    float3 _BoundsSize;
    float3 _SpawnCenter;
    float3 _SpawnSize;
    float3 _ObstaclePos;
}

// --------------------------------------------------------------------
// KERNEL: CS_Clear
// Reset per-particle accumulators (acceleration, density, pressure).
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_Clear(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    p.acceleration = 0.0;
    p.density = _RestDensity;
    p.pressure = 0.0;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_DensityPressure
// Compute density and pressure for each particle via brute-force neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_DensityPressure(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle self = Particles[idx];

    float h = _SmoothingRadius;
    float h2 = h * h;
    float poly6 = 315.0 / (64.0 * PI * pow(h, 9.0));
    float density = 0.0;

    // Loop over all particles
    for (uint j = 0; j < _ParticleCount; j++)
    {
        if (j == idx) continue;
        Particle other = Particles[j];
        float3 r = self.position - other.position;
        float rSq = dot(r, r);
        if (rSq < h2)
        {
            float diff = (h2 - rSq);
            density += _ParticleMass * poly6 * pow(diff, 3.0);
        }
    }

    density = max(density, _RestDensity);
    self.density = density;
    self.pressure = _Stiffness * (density - _RestDensity);
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_ComputeForces
// Compute pressure, viscosity, and surface tension forces via brute-force neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ComputeForces(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle self = Particles[idx];
    float densitySelf = self.density;
    if (densitySelf < 1e-6) return;

    float h = _SmoothingRadius;
    float h2 = h * h;
    float h6 = pow(h, 6.0);

    float spikyGrad = -45.0 / (PI * h6);
    float viscLap = 45.0 / (PI * h6);

    float3 force = float3(0.0, _Gravity * densitySelf, 0.0);
    float3 colorGradient = float3(0.0, 0.0, 0.0);

    // Brute-force neighbor search: loop over all particles.
    for (uint j = 0; j < _ParticleCount; j++)
    {
        if (j == idx) continue;
        Particle other = Particles[j];
        float3 r = self.position - other.position;
        float rSq = dot(r, r);
        if (rSq > h2) continue;

        float dist = sqrt(rSq) + 1e-6;
        float3 dir = r / dist;

        float pressTerm = (self.pressure + other.pressure) / (2.0 * other.density);
        float3 gradW = spikyGrad * pow(h - dist, 2.0) * dir;
        force += -_ParticleMass * pressTerm * gradW;

        float3 dv = (other.velocity - self.velocity);
        float viscTerm = _Viscosity * _ParticleMass * dv / other.density;
        float lapW = viscLap * (h - dist);
        force += viscTerm * lapW;

        colorGradient += _ParticleMass * gradW / other.density;
    }

    float3 surfaceTension = _SurfaceTensionCoefficient * colorGradient;
    force += surfaceTension;

    self.acceleration = force / densitySelf;
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_XSPH
// Optional velocity smoothing step via brute-force neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_XSPH(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle self = Particles[idx];
    float h = _SmoothingRadius;
    float h2 = h * h;
    float poly6 = 315.0 / (64.0 * PI * pow(h, 9.0));

    float3 velocityCorrection = float3(0.0, 0.0, 0.0);
    float normFactor = 0.0;

    for (uint j = 0; j < _ParticleCount; j++)
    {
        if (j == idx) continue;
        Particle other = Particles[j];
        float3 r = self.position - other.position;
        float rSq = dot(r, r);
        if (rSq < h2)
        {
            float W = poly6 * pow(h2 - rSq, 3.0);
            float rho_ij = 0.5 * (self.density + other.density);
            float3 dv = (other.velocity - self.velocity);

            velocityCorrection += dv * W * (_ParticleMass / rho_ij);
            normFactor += W * (_ParticleMass / rho_ij);
        }
    }

    if (normFactor > 1e-6)
    {
        velocityCorrection *= (_XSPHEpsilon / normFactor);
        self.velocity += velocityCorrection;
    }
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_VV_HalfStep
// Velocity Verlet half-step update.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VV_HalfStep(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    p.velocity += 0.5 * _DeltaTime * p.acceleration;
    p.position += p.velocity * _DeltaTime;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_VV_FullStep
// Velocity Verlet full-step update.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VV_FullStep(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    p.velocity += 0.5 * _DeltaTime * p.acceleration;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_Boundaries
// Clamp particles within a bounding box with bounce damping.
// --------------------------------------------------------------------

[numthreads(256, 1, 1)]
void CS_Boundaries(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    float3 halfSize = _BoundsSize * 0.5;
    float3 minBound = _BoundsCenter - halfSize;
    float3 maxBound = _BoundsCenter + halfSize;

    // Define a boundary stiffness and damping factor
    float boundaryStiffness = 800.0;  // Try a lower value than before
    float velocityDamping = 0.5;       // Increase damping to reduce bounce
    float epsilon = 0.01;             // Small offset

    // X-axis correction
    if (p.position.x < minBound.x)
    {
        float penetration = minBound.x - p.position.x;
        p.acceleration.x += boundaryStiffness * penetration;
        p.position.x = minBound.x + epsilon;
        p.velocity.x = abs(p.velocity.x) * velocityDamping;
    }
    else if (p.position.x > maxBound.x)
    {
        float penetration = p.position.x - maxBound.x;
        p.acceleration.x -= boundaryStiffness * penetration;
        p.position.x = maxBound.x - epsilon;
        p.velocity.x = -abs(p.velocity.x) * velocityDamping;
    }

    // Y-axis correction
    if (p.position.y < minBound.y)
    {
        float penetration = minBound.y - p.position.y;
        p.acceleration.y += boundaryStiffness * penetration;
        p.position.y = minBound.y + epsilon;
        p.velocity.y = abs(p.velocity.y) * velocityDamping;
    }
    else if (p.position.y > maxBound.y)
    {
        float penetration = p.position.y - maxBound.y;
        p.acceleration.y -= boundaryStiffness * penetration;
        p.position.y = maxBound.y - epsilon;
        p.velocity.y = -abs(p.velocity.y) * velocityDamping;
    }

    // Z-axis correction
    if (p.position.z < minBound.z)
    {
        float penetration = minBound.z - p.position.z;
        p.acceleration.z += boundaryStiffness * penetration;
        p.position.z = minBound.z + epsilon;
        p.velocity.z = abs(p.velocity.z) * velocityDamping;
    }
    else if (p.position.z > maxBound.z)
    {
        float penetration = p.position.z - maxBound.z;
        p.acceleration.z -= boundaryStiffness * penetration;
        p.position.z = maxBound.z - epsilon;
        p.velocity.z = -abs(p.velocity.z) * velocityDamping;
    }

    // Optionally, remove or reduce the jitter if it's contributing to instability
    // (float3 jitter = ... ; p.position += jitter;)

    Particles[idx] = p;
}





// --------------------------------------------------------------------
// KERNEL: CS_ObstacleCollision
// Handle simple sphere obstacle collisions with damping.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ObstacleCollision(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    float obstRadius = _ObstacleRadius;
    if (obstRadius <= 0.0) return;

    float3 toParticle = p.position - _ObstaclePos;
    float dist = length(toParticle);

    if (dist < obstRadius && dist > 1e-6)
    {
        float penetration = obstRadius - dist;
        float3 normal = toParticle / dist;
        p.position += normal * penetration;
        p.velocity = reflect(p.velocity, normal) * _ParticleCollisionDamping;
    }
    else if (dist <= 1e-6)
    {
        p.position += float3(0, obstRadius + 0.01, 0);
        p.velocity = reflect(p.velocity, float3(0, 1, 0)) * _ParticleCollisionDamping;
    }
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_VelocityDamping
// Additional velocity damping to help particles settle.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VelocityDamping(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    float speed = length(p.velocity);
    if (speed < 0.01)
    {
        p.velocity = float3(0.0, 0.0, 0.0);
    }
    else
    {
        p.velocity *= 0.98;
    }
    Particles[idx] = p;
}
