// Each #pragma kernel line tells Unity about a kernel entry point.
#pragma kernel CS_Clear
#pragma kernel CS_ClearGrid
#pragma kernel CS_BuildGrid
#pragma kernel CS_DensityPressure
#pragma kernel CS_ComputeForces
#pragma kernel CS_XSPH
#pragma kernel CS_VV_HalfStep
#pragma kernel CS_VV_FullStep
#pragma kernel CS_Boundaries
#pragma kernel CS_ObstacleCollision
#pragma kernel CS_VelocityDamping

static const float PI = 3.14159265359;

// --------------------------------------------------------------------
// Utility: Pseudo-Random Generator
// A simple hash-based function to break symmetry at boundaries.
// --------------------------------------------------------------------
float rand(float2 co)
{
    return frac(sin(dot(co, float2(12.9898, 78.233))) * 43758.5453);
}

// --------------------------------------------------------------------
// Data Structures
// --------------------------------------------------------------------
struct Particle
{
    float3 position;
    float3 velocity;
    float3 acceleration;
    float  density;
    float  pressure;
};

// Buffer containing all particles
RWStructuredBuffer<Particle> Particles;

// Grid buffers for spatial hashing:
RWStructuredBuffer<int> GridCounts;   // Array of length (gridResolutionX * gridResolutionY * gridResolutionZ)
RWStructuredBuffer<int> GridIndices;  // Array of length (totalCells * _MaxParticlesPerCell)

// --------------------------------------------------------------------
// Simulation Parameters
// --------------------------------------------------------------------
cbuffer SimulationParams
{
    int   _ParticleCount;
    float _DeltaTime;
    float _ParticleMass;
    float _RestDensity;
    float _Stiffness;
    float _Viscosity;
    float _SmoothingRadius;
    float _Gravity;
    float _SurfaceTensionCoefficient;
    float _XSPHEpsilon;
    float _ParticleCollisionDamping;
    float _ObstacleRepulsionStiffness;
    float _ObstacleRadius;
    float3 _BoundsCenter;
    float3 _BoundsSize;
    float3 _SpawnCenter;
    float3 _SpawnSize;
    float3 _ObstaclePos;

    // New grid parameters:
    int _GridResolutionX;
    int _GridResolutionY;
    int _GridResolutionZ;
    int _MaxParticlesPerCell;
    float _CellSize;
    float3 _MinBound;
}

// --------------------------------------------------------------------
// KERNEL: CS_Clear
// Reset per-particle accumulators (acceleration, density, pressure).
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_Clear(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    p.acceleration = 0.0;
    p.density = _RestDensity;
    p.pressure = 0.0;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_ClearGrid
// Reset the grid cell particle counts.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ClearGrid(uint3 id : SV_DispatchThreadID)
{
    uint cellIndex = id.x;
    int totalCells = _GridResolutionX * _GridResolutionY * _GridResolutionZ;
    if (cellIndex >= totalCells) return;
    GridCounts[cellIndex] = 0;
}

// --------------------------------------------------------------------
// KERNEL: CS_BuildGrid
// For each particle, compute its grid cell and store its index.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_BuildGrid(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;
    Particle p = Particles[idx];
    float3 pos = p.position;
    int3 cellCoord = int3(floor((pos - _MinBound) / _CellSize));
    // Clamp to valid grid coordinates
    cellCoord = clamp(cellCoord, int3(0,0,0), int3(_GridResolutionX - 1, _GridResolutionY - 1, _GridResolutionZ - 1));
    int cellIndex = cellCoord.x + cellCoord.y * _GridResolutionX + cellCoord.z * _GridResolutionX * _GridResolutionY;
    uint count;
    InterlockedAdd(GridCounts[cellIndex], 1, count);
    if (count < _MaxParticlesPerCell)
    {
        int offset = cellIndex * _MaxParticlesPerCell + count;
        GridIndices[offset] = idx;
    }
}

// --------------------------------------------------------------------
// KERNEL: CS_DensityPressure
// Compute density and pressure using neighbor particles from nearby grid cells.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_DensityPressure(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle self = Particles[idx];
    float h = _SmoothingRadius;
    float h2 = h * h;
    float poly6 = 315.0 / (64.0 * PI * pow(h, 9.0));
    float density = 0.0;

    float3 pos = self.position;
    float3 minBound = _MinBound;
    int3 cell = int3(floor((pos - minBound) / _CellSize));

    // Loop over neighboring cells (3x3x3)
    for (int z = cell.z - 1; z <= cell.z + 1; z++)
    {
        for (int y = cell.y - 1; y <= cell.y + 1; y++)
        {
            for (int x = cell.x - 1; x <= cell.x + 1; x++)
            {
                if (x < 0 || x >= _GridResolutionX || y < 0 || y >= _GridResolutionY || z < 0 || z >= _GridResolutionZ)
                    continue;
                int neighborCellIndex = x + y * _GridResolutionX + z * _GridResolutionX * _GridResolutionY;
                int neighborCount = GridCounts[neighborCellIndex];
                for (int k = 0; k < neighborCount; k++)
                {
                    int j = GridIndices[neighborCellIndex * _MaxParticlesPerCell + k];
                    if (j == idx) continue;
                    Particle other = Particles[j];
                    float3 r = self.position - other.position;
                    float rSq = dot(r, r);
                    if (rSq < h2)
                    {
                        float diff = (h2 - rSq);
                        density += _ParticleMass * poly6 * pow(diff, 3.0);
                    }
                }
            }
        }
    }
    density = max(density, _RestDensity);
    self.density = density;
    self.pressure = _Stiffness * (density - _RestDensity);
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_ComputeForces
// Compute forces (pressure, viscosity, surface tension) using grid-based neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ComputeForces(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle self = Particles[idx];
    float densitySelf = self.density;
    if (densitySelf < 1e-6) return;

    float h = _SmoothingRadius;
    float h2 = h * h;
    float h6 = pow(h, 6.0);

    float spikyGrad = -45.0 / (PI * h6);
    float viscLap = 45.0 / (PI * h6);

    float3 force = float3(0.0, _Gravity * densitySelf, 0.0);
    float3 colorGradient = float3(0.0, 0.0, 0.0);

    float3 pos = self.position;
    float3 minBound = _MinBound;
    int3 cell = int3(floor((pos - minBound) / _CellSize));

    for (int z = cell.z - 1; z <= cell.z + 1; z++)
    {
        for (int y = cell.y - 1; y <= cell.y + 1; y++)
        {
            for (int x = cell.x - 1; x <= cell.x + 1; x++)
            {
                if (x < 0 || x >= _GridResolutionX || y < 0 || y >= _GridResolutionY || z < 0 || z >= _GridResolutionZ)
                    continue;
                int neighborCellIndex = x + y * _GridResolutionX + z * _GridResolutionX * _GridResolutionY;
                int neighborCount = GridCounts[neighborCellIndex];
                for (int k = 0; k < neighborCount; k++)
                {
                    int j = GridIndices[neighborCellIndex * _MaxParticlesPerCell + k];
                    if (j == idx) continue;
                    Particle other = Particles[j];
                    float3 r = self.position - other.position;
                    float rSq = dot(r, r);
                    if (rSq > h2) continue;
                    float dist = sqrt(rSq) + 1e-6;
                    float3 dir = r / dist;

                    float pressTerm = (self.pressure + other.pressure) / (2.0 * other.density);
                    float3 gradW = spikyGrad * pow(h - dist, 2.0) * dir;
                    force += -_ParticleMass * pressTerm * gradW;

                    float3 dv = (other.velocity - self.velocity);
                    float viscTerm = _Viscosity * _ParticleMass;
                    float lapW = viscLap * (h - dist);
                    force += (viscTerm * dv / other.density) * lapW;

                    colorGradient += _ParticleMass * gradW / other.density;
                }
            }
        }
    }
    float3 surfaceTension = _SurfaceTensionCoefficient * colorGradient;
    force += surfaceTension;

    self.acceleration = force / densitySelf;
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_XSPH
// Optional velocity smoothing using grid-based neighbor search.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_XSPH(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle self = Particles[idx];
    float h = _SmoothingRadius;
    float h2 = h * h;
    float poly6 = 315.0 / (64.0 * PI * pow(h, 9.0));

    float3 velocityCorrection = float3(0.0, 0.0, 0.0);
    float normFactor = 0.0;

    float3 pos = self.position;
    float3 minBound = _MinBound;
    int3 cell = int3(floor((pos - minBound) / _CellSize));

    for (int z = cell.z - 1; z <= cell.z + 1; z++)
    {
        for (int y = cell.y - 1; y <= cell.y + 1; y++)
        {
            for (int x = cell.x - 1; x <= cell.x + 1; x++)
            {
                if (x < 0 || x >= _GridResolutionX || y < 0 || y >= _GridResolutionY || z < 0 || z >= _GridResolutionZ)
                    continue;
                int neighborCellIndex = x + y * _GridResolutionX + z * _GridResolutionX * _GridResolutionY;
                int neighborCount = GridCounts[neighborCellIndex];
                for (int k = 0; k < neighborCount; k++)
                {
                    int j = GridIndices[neighborCellIndex * _MaxParticlesPerCell + k];
                    if (j == idx) continue;
                    Particle other = Particles[j];
                    float3 r = self.position - other.position;
                    float rSq = dot(r, r);
                    if (rSq < h2)
                    {
                        float W = poly6 * pow(h2 - rSq, 3.0);
                        float rho_ij = 0.5 * (self.density + other.density);
                        float3 dv = (other.velocity - self.velocity);
                        velocityCorrection += dv * W * (_ParticleMass / rho_ij);
                        normFactor += W * (_ParticleMass / rho_ij);
                    }
                }
            }
        }
    }
    if (normFactor > 1e-6)
    {
        velocityCorrection *= (_XSPHEpsilon / normFactor);
        self.velocity += velocityCorrection;
    }
    Particles[idx] = self;
}

// --------------------------------------------------------------------
// KERNEL: CS_VV_HalfStep
// Velocity Verlet half-step update.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VV_HalfStep(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    p.velocity += 0.5 * _DeltaTime * p.acceleration;
    p.position += p.velocity * _DeltaTime;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_VV_FullStep
// Velocity Verlet full-step update.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VV_FullStep(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    p.velocity += 0.5 * _DeltaTime * p.acceleration;
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_Boundaries
// Bounce particles off the boundaries with a small random tangential offset.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_Boundaries(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    float3 halfSize = _BoundsSize * 0.5;
    float3 minBound = _BoundsCenter - halfSize;
    float3 maxBound = _BoundsCenter + halfSize;
    
    float velocityDamping = 0.9;
    float offset = 1e-3; // small offset to break alignment

    // X-axis
    if (p.position.x < minBound.x)
    {
        float angle = rand(float2(p.position.y, p.position.z)) * 6.28318530718;
        float2 tangentOffset = float2(cos(angle), sin(angle)) * offset;
        p.position.x = minBound.x;
        p.position.y += tangentOffset.x;
        p.position.z += tangentOffset.y;
        if (p.velocity.x < 0) p.velocity.x = -p.velocity.x * velocityDamping;
    }
    else if (p.position.x > maxBound.x)
    {
        float angle = rand(float2(p.position.y, p.position.z)) * 6.28318530718;
        float2 tangentOffset = float2(cos(angle), sin(angle)) * offset;
        p.position.x = maxBound.x;
        p.position.y += tangentOffset.x;
        p.position.z += tangentOffset.y;
        if (p.velocity.x > 0) p.velocity.x = -p.velocity.x * velocityDamping;
    }

    // Y-axis
    if (p.position.y < minBound.y)
    {
        float angle = rand(float2(p.position.x, p.position.z)) * 6.28318530718;
        float2 tangentOffset = float2(cos(angle), sin(angle)) * offset;
        p.position.y = minBound.y;
        p.position.x += tangentOffset.x;
        p.position.z += tangentOffset.y;
        if (p.velocity.y < 0) p.velocity.y = -p.velocity.y * velocityDamping;
    }
    else if (p.position.y > maxBound.y)
    {
        float angle = rand(float2(p.position.x, p.position.z)) * 6.28318530718;
        float2 tangentOffset = float2(cos(angle), sin(angle)) * offset;
        p.position.y = maxBound.y;
        p.position.x += tangentOffset.x;
        p.position.z += tangentOffset.y;
        if (p.velocity.y > 0) p.velocity.y = -p.velocity.y * velocityDamping;
    }

    // Z-axis
    if (p.position.z < minBound.z)
    {
        float angle = rand(float2(p.position.x, p.position.y)) * 6.28318530718;
        float2 tangentOffset = float2(cos(angle), sin(angle)) * offset;
        p.position.z = minBound.z;
        p.position.x += tangentOffset.x;
        p.position.y += tangentOffset.y;
        if (p.velocity.z < 0) p.velocity.z = -p.velocity.z * velocityDamping;
    }
    else if (p.position.z > maxBound.z)
    {
        float angle = rand(float2(p.position.x, p.position.y)) * 6.28318530718;
        float2 tangentOffset = float2(cos(angle), sin(angle)) * offset;
        p.position.z = maxBound.z;
        p.position.x += tangentOffset.x;
        p.position.y += tangentOffset.y;
        if (p.velocity.z > 0) p.velocity.z = -p.velocity.z * velocityDamping;
    }
    
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_ObstacleCollision
// Handle simple sphere obstacle collisions with damping.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_ObstacleCollision(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    float obstRadius = _ObstacleRadius;
    if (obstRadius <= 0.0) return;

    float3 toParticle = p.position - _ObstaclePos;
    float dist = length(toParticle);

    if (dist < obstRadius && dist > 1e-6)
    {
        float penetration = obstRadius - dist;
        float3 normal = toParticle / dist;
        p.position += normal * penetration;
        p.velocity = reflect(p.velocity, normal) * _ParticleCollisionDamping;
    }
    else if (dist <= 1e-6)
    {
        p.position += float3(0, obstRadius + 0.01, 0);
        p.velocity = reflect(p.velocity, float3(0, 1, 0)) * _ParticleCollisionDamping;
    }
    Particles[idx] = p;
}

// --------------------------------------------------------------------
// KERNEL: CS_VelocityDamping
// Additional velocity damping to help particles settle.
// --------------------------------------------------------------------
[numthreads(256, 1, 1)]
void CS_VelocityDamping(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _ParticleCount) return;

    Particle p = Particles[idx];
    float speed = length(p.velocity);
    if (speed < 0.01)
    {
        p.velocity = float3(0.0, 0.0, 0.0);
    }
    else
    {
        p.velocity *= 0.98;
    }
    Particles[idx] = p;
}
